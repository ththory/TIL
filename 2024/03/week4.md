0327수

- 인스턴스 멤버 vs 정적 멤버
  - 인스턴스 필드는 힙 영역에 저장되나 인스턴스 메소드는 별도의 메소드 영역에 저장되어 참조된다.
  - 모든 메소드를 저장하면 메모리를 많이 차지하기 때문..
- 정적 블록
  - 클래스가 로드될 때 실행되어 초기화 작업을 수행할 수 있다.
- final의 사용
  - final은 값이 변경되면 안될때 사용한다 
  - 공유해서 사용하고 변경이 필요없다면 static final로 선언하면 된다. 
- 상수를 정적 블럭에서 초기화하는 경우
  - 시스템 환경변수를 가져오는 등 복잡한 로직이 있을 경우
  - 예외처리가 필요할 경우
- 클래스를 참조하는 과정
  - 클래스 로딩 > 클래스 링킹 > 클래스 초기화
- 접근 제한자
  - Public 동네사람들 다 사용할 수 있게
  - Protected 사촌까지는 사용할 수 있게
  - Default 우리 가족만 사용할 수 있게
  - private 나만 사용할 수 있게
- 같은 패키지: 같은 공간에 빌드될 수 있는 것
- 싱글톤 패턴 vs 정적 메소드를 사용하는 정적 객체
  - 정적 객체는 상태를 가질 수 없다. (사용되는 메소드와 필드값도 정적이어야하기 때문...)
  - 그러나 싱글톤은 생성된 단 하나의 객체 내에 상태를 가질 수 있다!! 예를 들어 카프카 설정과 같이.
  - 싱글톤은 단톡방의 공지사항과 같다. 단 하나만 갖고 있으며 상태를 가지고 있다!
- 부모 클래스의 생성자를 자식 클래스에도 수행되도록하기 위해 super를 해야만 한다.
  - 안하면? 자식 클래스에는 부모 클래스의 생성자가 수행되지 않아 예상치 못한 문제가 발생할 수 있다
- 오버라이딩? 자식이 목마타고 있는 것을 상상..
- super.{{method}}로 Override 내에서 부모 클래스의 메소드를 사용할 수 있다
- final 클래스와 final 메소드는 "최종" 형태임을 의미한다. 따라서 자식 클래스에 의해 상속되거나 오버라이드 되지 않는다.

---

0328목

- 다형성: 동일한 방법을 사용하지만 다른 결과를 보이는 것. 필드 다형성과 매개변수 다형성이 있다
  - 부모 대신 자식이 일할 수 있다.
  - 일하는 방식은 자식이 새롭게 정의하면 자식의 방식대로 일한다.
